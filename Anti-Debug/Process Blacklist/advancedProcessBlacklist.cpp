#include <Windows.h>
#include <winternl.h>
#include <ntstatus.h>
#include <iostream>

typedef NTSTATUS(WINAPI* pNtQuerySystemInformation)(
    _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Inout_   PVOID                    SystemInformation,
    _In_      ULONG                    SystemInformationLength,
    _Out_opt_ PULONG                   ReturnLength
    );

const wchar_t* blacklist[] = { L"ida.exe",L"ida64.exe",L"x32.exe",L"x64.exe",L"procmon.exe",L"process hacker.exe",L"process explorer.exe" };
int size = 7;

bool check_debugger() {

    HMODULE hNtDll = LoadLibrary(L"ntdll.dll");
    if (hNtDll == NULL) {
        std::cerr << "ntdll.dll yuklenemedi" << std::endl;
        return 1;
    }

    pNtQuerySystemInformation NtQuerySystemInformation = (pNtQuerySystemInformation)GetProcAddress(hNtDll, "NtQuerySystemInformation");
    if (NtQuerySystemInformation == NULL) {
        std::cerr << "NtQuerySystemInformation bulunamadi" << std::endl;
        return 1;
    }

    ULONG bufferSize = 0;
    NTSTATUS status = NtQuerySystemInformation(SystemProcessInformation, NULL, 0, &bufferSize);
    if (status != STATUS_INFO_LENGTH_MISMATCH) {
        std::cerr << "Buffer boyutu alinamadi" << std::endl;
        return 1;
    }

    PVOID buffer = VirtualAlloc(NULL, bufferSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (buffer == NULL) {
        std::cerr << "Bellek ayrilamadi" << std::endl;
        return 1;
    }

    status = NtQuerySystemInformation(SystemProcessInformation, buffer, bufferSize, NULL);
    if (!NT_SUCCESS(status)) {
        std::cerr << "İşlem bilgileri alınamadı: " << status << std::endl;
        VirtualFree(buffer, 0, MEM_RELEASE);
        return 1;
    }

    PSYSTEM_PROCESS_INFORMATION pInfo = (PSYSTEM_PROCESS_INFORMATION)buffer;
    while (true) {
        if (pInfo->ImageName.Buffer != NULL) {

            int i{ 0 };

            while (i < size) {
                if (wcscmp(pInfo->ImageName.Buffer, blacklist[i]) == 0)
                {
                    VirtualFree(buffer, 0, MEM_RELEASE);
                    
                    return true;

                }
                i++;
            }
        }

        if (pInfo->NextEntryOffset == 0)
            break;
        pInfo = (PSYSTEM_PROCESS_INFORMATION)(((LPBYTE)pInfo) + pInfo->NextEntryOffset);
    }

    VirtualFree(buffer, 0, MEM_RELEASE);

    return false;

}

int main() {

    if (check_debugger()) {
        std::cout << "Debugger Detected";
        ExitProcess(0);
    }
    //If not, go on


    
    return 0;
}
